<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE WIDTH="100%" CLASS="hdft" CELLSPACING="0"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon Feb 16 10:40:34 CST 2015)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="e.html">net.jperf.aop</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">AgnosticTimingAspect.java</SPAN>]</H2><TABLE WIDTH="100%" CELLSPACING="0"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>AgnosticTimingAspect.java</TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>93%  (532/571)</TD><TD>93%  (106.4/114)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE WIDTH="100%" CLASS="cn" CELLSPACING="0"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">AgnosticTimingAspect</A></TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>93%  (532/571)</TD><TD>93%  (106.4/114)</TD></TR><TR><TD CLASS="f"><A HREF="#1">getStopWatchTag (Profiled, AbstractJoinPoint, Object, Throwable): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>84%  (70/83)</TD><TD>87%  (13.9/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">runProfiledMethod (AbstractJoinPoint, Profiled, LoggingStopWatch): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>86%  (105/122)</TD><TD>97%  (15.6/16)</TD></TR><TR><TD CLASS="f"><A HREF="#3">getThresholdDefaultValue (Profiled): long</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>91%  (30/33)</TD><TD CLASS="h">79%  (7.9/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">getStopWatchMessage (Profiled, AbstractJoinPoint, Object, Throwable): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (63/68)</TD><TD>85%  (11/13)</TD></TR><TR><TD CLASS="f"><A HREF="#5">evaluateJexlAndSetOnResult (StringBuilder, String, JexlContext): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>95%  (20/21)</TD><TD>88%  (7/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">AgnosticTimingAspect (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#7">appendFinalPart (StringBuilder, String, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">appendNonJexlText (StringBuilder, String, int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#9">chooseThreshold (Profiled): long</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (24/24)</TD><TD>100% (8/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">evaluateJexl (String, AbstractJoinPoint, Object, Throwable): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (54/54)</TD><TD>100% (11/11)</TD></TR><TR><TD CLASS="f"><A HREF="#b">getJexlExpression (String): Expression</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">getThresholdFromConfig (): long</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#d">lastCloseBracketIndex (String, int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">populateJexlContext (AbstractJoinPoint, Object, Throwable): JexlContext</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (81/81)</TD><TD>100% (13/13)</TD></TR><TR><TD CLASS="f"><A HREF="#f">textBetweenBrackets (String, int, int): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (1/1)</TD></TR></TABLE><P></P><TABLE WIDTH="100%" CLASS="s" CELLSPACING="0"><TR><TD CLASS="l">1</TD><TD>/*</TD></TR><TR><TD CLASS="l">2</TD><TD> * Copyright (c) 2008-2015 JPerf</TD></TR><TR><TD CLASS="l">3</TD><TD> * All rights reserved.  http://www.jperf.net</TD></TR><TR><TD CLASS="l">4</TD><TD> *</TD></TR><TR><TD CLASS="l">5</TD><TD> * Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);</TD></TR><TR><TD CLASS="l">6</TD><TD> * you may not use this file except in compliance with the License.</TD></TR><TR><TD CLASS="l">7</TD><TD> * You may obtain a copy of the License at</TD></TR><TR><TD CLASS="l">8</TD><TD> *</TD></TR><TR><TD CLASS="l">9</TD><TD> *      http://www.apache.org/licenses/LICENSE-2.0</TD></TR><TR><TD CLASS="l">10</TD><TD> *</TD></TR><TR><TD CLASS="l">11</TD><TD> * Unless required by applicable law or agreed to in writing, software</TD></TR><TR><TD CLASS="l">12</TD><TD> * distributed under the License is distributed on an &#34;AS IS&#34; BASIS,</TD></TR><TR><TD CLASS="l">13</TD><TD> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</TD></TR><TR><TD CLASS="l">14</TD><TD> * See the License for the specific language governing permissions and</TD></TR><TR><TD CLASS="l">15</TD><TD> * limitations under the License.</TD></TR><TR><TD CLASS="l">16</TD><TD> */</TD></TR><TR><TD CLASS="l">17</TD><TD> </TD></TR><TR><TD CLASS="l">18</TD><TD>package net.jperf.aop;</TD></TR><TR><TD CLASS="l">19</TD><TD> </TD></TR><TR><TD CLASS="l">20</TD><TD>import org.apache.commons.jexl.Expression;</TD></TR><TR><TD CLASS="l">21</TD><TD>import org.apache.commons.jexl.ExpressionFactory;</TD></TR><TR><TD CLASS="l">22</TD><TD>import org.apache.commons.jexl.JexlContext;</TD></TR><TR><TD CLASS="l">23</TD><TD>import org.apache.commons.jexl.context.HashMapContext;</TD></TR><TR><TD CLASS="l">24</TD><TD>import net.jperf.LoggingStopWatch;</TD></TR><TR><TD CLASS="l">25</TD><TD>import net.jperf.helpers.JperfProperties;</TD></TR><TR><TD CLASS="l">26</TD><TD> </TD></TR><TR><TD CLASS="l">27</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">28</TD><TD>import java.util.concurrent.ConcurrentHashMap;</TD></TR><TR><TD CLASS="l">29</TD><TD> </TD></TR><TR><TD CLASS="l">30</TD><TD>/**</TD></TR><TR><TD CLASS="l">31</TD><TD> * This AgnosticTimingAspect class contains all the logic for executing a profiled method with appropriate timing calls,</TD></TR><TR><TD CLASS="l">32</TD><TD> * but in an AOP-framework-agnostic way. You may choose to either extend or wrap this class to create an aspect in</TD></TR><TR><TD CLASS="l">33</TD><TD> * your desired framework. For example, if you look at the {@link AbstractTimingAspect}, you can see</TD></TR><TR><TD CLASS="l">34</TD><TD> * that it delegates all functionality to this class - it just includes the necessary AspectJ annotations and wraps</TD></TR><TR><TD CLASS="l"><A NAME="0">35</A></TD><TD> * the AspectJ-specific ProceedingJoinPoint as an {@link AbstractJoinPoint}.</TD></TR><TR><TD CLASS="l">36</TD><TD> *</TD></TR><TR><TD CLASS="l">37</TD><TD> * @author Marcin Zajączkowski, Alex Devine </TD></TR><TR><TD CLASS="l">38</TD><TD> */</TD></TR><TR CLASS="c"><TD CLASS="l">39</TD><TD>public class AgnosticTimingAspect {</TD></TR><TR><TD CLASS="l">40</TD><TD>    private static final String DEFAULT_THRESHOLD_CONFIG_KEY = &#34;net.jperf.threshold.default&#34;;</TD></TR><TR><TD CLASS="l">41</TD><TD> </TD></TR><TR><TD CLASS="l">42</TD><TD>    /**</TD></TR><TR><TD CLASS="l">43</TD><TD>     * This Map is used to cache compiled JEXL expressions. While theoretically unbounded, in reality the number of</TD></TR><TR><TD CLASS="l">44</TD><TD>     * possible keys is equivalent to the number of unique JEXL expressions created in @Profiled annotations, which</TD></TR><TR><TD CLASS="l">45</TD><TD>     * will have to be loaded in memory anyway when the class is loaded.</TD></TR><TR><TD CLASS="l">46</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">47</TD><TD>    private Map&lt;String, Expression&gt; jexlExpressionCache = new ConcurrentHashMap&lt;String, Expression&gt;(64, .75F, 16);</TD></TR><TR><TD CLASS="l">48</TD><TD> </TD></TR><TR><TD CLASS="l">49</TD><TD>    /**</TD></TR><TR><TD CLASS="l">50</TD><TD>     * This method actually executes the profiled method. Your AOP-framework-specific class should delegate to this</TD></TR><TR><TD CLASS="l">51</TD><TD>     * method to proceed with execution.</TD></TR><TR><TD CLASS="l">52</TD><TD>     *</TD></TR><TR><TD CLASS="l">53</TD><TD>     * @param joinPoint The AOP join point - usually this will just be a simple wrapper around the</TD></TR><TR><TD CLASS="l">54</TD><TD>     *                  AOP-framework-specific join point.</TD></TR><TR><TD CLASS="l">55</TD><TD>     * @param profiled  The Profiled annotation that was set on the method being profiled.</TD></TR><TR><TD CLASS="l">56</TD><TD>     * @param stopWatch This LogginStopWatch should be started JUST before this method is called.</TD></TR><TR><TD CLASS="l">57</TD><TD>     * @return The return value from the profiled method.</TD></TR><TR><TD CLASS="l">58</TD><TD>     * @throws Throwable Exception thrown by the profiled method will bubble up.</TD></TR><TR><TD CLASS="l"><A NAME="2">59</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">60</TD><TD>    public Object runProfiledMethod(AbstractJoinPoint joinPoint, Profiled profiled, LoggingStopWatch stopWatch)</TD></TR><TR><TD CLASS="l">61</TD><TD>            throws Throwable {</TD></TR><TR><TD CLASS="l">62</TD><TD>        //if we're not going to end up logging the stopwatch, just run the wrapped method</TD></TR><TR CLASS="c"><TD CLASS="l">63</TD><TD>        if (!stopWatch.isLogging()) {</TD></TR><TR CLASS="c"><TD CLASS="l">64</TD><TD>            return joinPoint.proceed();</TD></TR><TR><TD CLASS="l">65</TD><TD>        }</TD></TR><TR><TD CLASS="l">66</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">67</TD><TD>        long threshold = chooseThreshold(profiled);</TD></TR><TR><TD CLASS="l">68</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">69</TD><TD>        stopWatch.setTimeThreshold(threshold);</TD></TR><TR CLASS="c"><TD CLASS="l">70</TD><TD>        stopWatch.setNormalAndSlowSuffixesEnabled(profiled.normalAndSlowSuffixesEnabled());</TD></TR><TR><TD CLASS="l">71</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">72</TD><TD>        Object retVal = null;</TD></TR><TR CLASS="c"><TD CLASS="l">73</TD><TD>        Throwable exceptionThrown = null;</TD></TR><TR><TD CLASS="l">74</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">75</TD><TD>            return retVal = joinPoint.proceed();</TD></TR><TR CLASS="c"><TD CLASS="l">76</TD><TD>        } catch (Throwable t) {</TD></TR><TR CLASS="c"><TD CLASS="l">77</TD><TD>            throw exceptionThrown = t;</TD></TR><TR><TD CLASS="l">78</TD><TD>        } finally {</TD></TR><TR CLASS="c"><TD CLASS="l">79</TD><TD>            String tag = getStopWatchTag(profiled, joinPoint, retVal, exceptionThrown);</TD></TR><TR CLASS="c"><TD CLASS="l">80</TD><TD>            String message = getStopWatchMessage(profiled, joinPoint, retVal, exceptionThrown);</TD></TR><TR><TD CLASS="l">81</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">82</TD><TD>            if (profiled.logFailuresSeparately()) {</TD></TR><TR CLASS="p"><TD TITLE="57% line coverage (23 out of 40 instructions)" CLASS="l">83</TD><TD TITLE="57% line coverage (23 out of 40 instructions)">                tag = (exceptionThrown == null) ? tag + &#34;.success&#34; : tag + &#34;.failure&#34;;</TD></TR><TR><TD CLASS="l">84</TD><TD>            }</TD></TR><TR><TD CLASS="l">85</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">86</TD><TD>            stopWatch.stop(tag, message);</TD></TR><TR CLASS="c"><TD CLASS="l">87</TD><TD>        }</TD></TR><TR><TD CLASS="l">88</TD><TD>    }</TD></TR><TR><TD CLASS="l">89</TD><TD> </TD></TR><TR><TD CLASS="l">90</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="9">91</A></TD><TD>     * Defaults to 0ms. First checks whether a non-negative value is set on the annotation, and if so will use it,</TD></TR><TR><TD CLASS="l">92</TD><TD>     * otherwise</TD></TR><TR><TD CLASS="l">93</TD><TD>     */</TD></TR><TR><TD CLASS="l">94</TD><TD>    private long chooseThreshold(Profiled profiled) {</TD></TR><TR CLASS="c"><TD CLASS="l">95</TD><TD>        long thresholdFromAnnotation = profiled.timeThreshold();</TD></TR><TR CLASS="c"><TD CLASS="l">96</TD><TD>        long thresholdFromConfig = getThresholdFromConfig();</TD></TR><TR CLASS="c"><TD CLASS="l">97</TD><TD>        long thresholdDefaultValue = getThresholdDefaultValue(profiled);</TD></TR><TR><TD CLASS="l">98</TD><TD> </TD></TR><TR><TD CLASS="l">99</TD><TD>        // if set on annotation, has higher priority than configured value</TD></TR><TR CLASS="c"><TD CLASS="l">100</TD><TD>        if (thresholdFromAnnotation &gt; thresholdDefaultValue) {</TD></TR><TR CLASS="c"><TD CLASS="l">101</TD><TD>            return thresholdFromAnnotation;</TD></TR><TR><TD CLASS="l">102</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">103</TD><TD>        if (thresholdFromConfig &gt; thresholdDefaultValue) {</TD></TR><TR CLASS="c"><TD CLASS="l">104</TD><TD>            return thresholdFromConfig;</TD></TR><TR><TD CLASS="l">105</TD><TD>        }</TD></TR><TR><TD CLASS="l">106</TD><TD> </TD></TR><TR><TD CLASS="l">107</TD><TD>        // after this point, 0 is the default value; thresholdDefaultValue above is -1, just to make it possible to</TD></TR><TR><TD CLASS="l">108</TD><TD>        // set no threshold (0ms) to override a configured positive value</TD></TR><TR CLASS="c"><TD CLASS="l">109</TD><TD>        return 0;</TD></TR><TR><TD CLASS="l">110</TD><TD>    }</TD></TR><TR><TD CLASS="l">111</TD><TD> </TD></TR><TR><TD CLASS="l">112</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="3">113</A></TD><TD>     * &#34;Cache&#34; the default annotation field value so we don't have to do reflection calls for every iteration; is not</TD></TR><TR><TD CLASS="l">114</TD><TD>     * changed between runs anyway.</TD></TR><TR><TD CLASS="l">115</TD><TD>     */</TD></TR><TR><TD CLASS="l">116</TD><TD>    private long getThresholdDefaultValue(Profiled profiled) {</TD></TR><TR CLASS="c"><TD CLASS="l">117</TD><TD>        String thresholdString = JperfProperties.INSTANCE.getProperty(DEFAULT_THRESHOLD_CONFIG_KEY);</TD></TR><TR CLASS="c"><TD CLASS="l">118</TD><TD>        if (thresholdString != null) {</TD></TR><TR><TD CLASS="l">119</TD><TD>            try {</TD></TR><TR CLASS="c"><TD CLASS="l">120</TD><TD>                return Long.valueOf(thresholdString);</TD></TR><TR><TD CLASS="l">121</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">122</TD><TD>            catch (NumberFormatException e) {</TD></TR><TR><TD CLASS="l">123</TD><TD>                // ignore</TD></TR><TR><TD CLASS="l">124</TD><TD>            }</TD></TR><TR><TD CLASS="l">125</TD><TD>        }</TD></TR><TR><TD CLASS="l">126</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">127</TD><TD>            long thresholdDefault = (Long)profiled.annotationType().getMethod(Profiled.THRESHOLD_FIELD_NAME).getDefaultValue();</TD></TR><TR CLASS="c"><TD CLASS="l">128</TD><TD>            JperfProperties.INSTANCE.setProperty(DEFAULT_THRESHOLD_CONFIG_KEY, String.valueOf(thresholdDefault));</TD></TR><TR><TD CLASS="l">129</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">130</TD><TD>        catch (NoSuchMethodException e) {</TD></TR><TR><TD CLASS="l">131</TD><TD>            // ignore</TD></TR><TR><TD CLASS="l">132</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">133</TD><TD>        catch (NullPointerException e) {</TD></TR><TR><TD CLASS="l">134</TD><TD>            // just means was not set in properties and cast throws NPE, ignore</TD></TR><TR CLASS="p"><TD TITLE="89% line coverage (17 out of 19 instructions)" CLASS="l">135</TD><TD TITLE="89% line coverage (17 out of 19 instructions)">        }</TD></TR><TR><TD CLASS="l">136</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">137</TD><TD>        return -1;</TD></TR><TR><TD CLASS="l"><A NAME="c">138</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">139</TD><TD> </TD></TR><TR><TD CLASS="l">140</TD><TD>    private long getThresholdFromConfig() {</TD></TR><TR><TD CLASS="l">141</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">142</TD><TD>            return Long.parseLong(JperfProperties.INSTANCE.getProperty(Profiled.THRESHOLD_FIELD_NAME));</TD></TR><TR><TD CLASS="l">143</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">144</TD><TD>        catch (Exception e) {</TD></TR><TR CLASS="c"><TD CLASS="l">145</TD><TD>            return -1;</TD></TR><TR><TD CLASS="l">146</TD><TD>        }</TD></TR><TR><TD CLASS="l">147</TD><TD>    }</TD></TR><TR><TD CLASS="l">148</TD><TD> </TD></TR><TR><TD CLASS="l">149</TD><TD>    /**</TD></TR><TR><TD CLASS="l">150</TD><TD>     * Helper method gets the tag to use for StopWatch logging. Performs JEXL evaluation if necessary.</TD></TR><TR><TD CLASS="l">151</TD><TD>     *</TD></TR><TR><TD CLASS="l">152</TD><TD>     * @param profiled        The profiled annotation that was attached to the method.</TD></TR><TR><TD CLASS="l">153</TD><TD>     * @param joinPoint       The AbstractJoinPoint encapulates the method around which this aspect advice runs.</TD></TR><TR><TD CLASS="l">154</TD><TD>     * @param returnValue     The value returned from the execution of the profiled method, or null if the method</TD></TR><TR><TD CLASS="l">155</TD><TD>     *                        returned void or an exception was thrown.</TD></TR><TR><TD CLASS="l">156</TD><TD>     * @param exceptionThrown The exception thrown, if any, by the profiled method. Will be null if the method</TD></TR><TR><TD CLASS="l">157</TD><TD>     *                        completed normally.</TD></TR><TR><TD CLASS="l"><A NAME="1">158</A></TD><TD>     * @return The value to use as the StopWatch tag.</TD></TR><TR><TD CLASS="l">159</TD><TD>     */</TD></TR><TR><TD CLASS="l">160</TD><TD>    protected String getStopWatchTag(Profiled profiled, AbstractJoinPoint joinPoint, Object returnValue, Throwable exceptionThrown) {</TD></TR><TR><TD CLASS="l">161</TD><TD>        String tag;</TD></TR><TR CLASS="c"><TD CLASS="l">162</TD><TD>        if (Profiled.DEFAULT_TAG_NAME.equals(profiled.tag())) {</TD></TR><TR><TD CLASS="l">163</TD><TD>            // look for properties-based default</TD></TR><TR><TD CLASS="l">164</TD><TD>            // if the tag name is not explicitly set on the Profiled annotation,</TD></TR><TR CLASS="c"><TD CLASS="l">165</TD><TD>            final String tagString = String.format(&#34;tag.%s.%s&#34;,</TD></TR><TR CLASS="c"><TD CLASS="l">166</TD><TD>                    joinPoint.getDeclaringClass().getName(),</TD></TR><TR CLASS="c"><TD CLASS="l">167</TD><TD>                    joinPoint.getMethodName());</TD></TR><TR><TD CLASS="l">168</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">169</TD><TD>            tag = JperfProperties.INSTANCE.getProperty(tagString);</TD></TR><TR CLASS="c"><TD CLASS="l">170</TD><TD>            String defaultTag = JperfProperties.INSTANCE.getProperty(&#34;tag&#34;);</TD></TR><TR><TD CLASS="l">171</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="93% line coverage (26 out of 28 instructions)" CLASS="l">172</TD><TD TITLE="93% line coverage (26 out of 28 instructions)">            if (tag == null &amp;&amp; defaultTag == null) {</TD></TR><TR><TD CLASS="l">173</TD><TD>                // fall back to using the name of the method being annotated.</TD></TR><TR CLASS="z"><TD CLASS="l">174</TD><TD>                tag = joinPoint.getMethodName();</TD></TR><TR><TD CLASS="l">175</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">176</TD><TD>            else if (tag != null &amp;&amp; tag.contains(&#34;{&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">177</TD><TD>                tag = evaluateJexl(tag, joinPoint, returnValue, exceptionThrown);</TD></TR><TR><TD CLASS="l">178</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">179</TD><TD>            else if (tag == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">180</TD><TD>                tag = evaluateJexl(defaultTag, joinPoint, returnValue, exceptionThrown);</TD></TR><TR><TD CLASS="l">181</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">182</TD><TD>        } else if (profiled.el() &amp;&amp; profiled.tag().contains(&#34;{&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">183</TD><TD>            tag = evaluateJexl(profiled.tag(), joinPoint, returnValue, exceptionThrown);</TD></TR><TR><TD CLASS="l">184</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">185</TD><TD>            tag = profiled.tag();</TD></TR><TR><TD CLASS="l">186</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">187</TD><TD>        return tag;</TD></TR><TR><TD CLASS="l">188</TD><TD>    }</TD></TR><TR><TD CLASS="l">189</TD><TD> </TD></TR><TR><TD CLASS="l">190</TD><TD> </TD></TR><TR><TD CLASS="l">191</TD><TD>    /**</TD></TR><TR><TD CLASS="l">192</TD><TD>     * Helper method get the message to use for StopWatch logging. Performs JEXL evaluation if necessary.</TD></TR><TR><TD CLASS="l">193</TD><TD>     *</TD></TR><TR><TD CLASS="l">194</TD><TD>     * @param profiled        The profiled annotation that was attached to the method.</TD></TR><TR><TD CLASS="l">195</TD><TD>     * @param joinPoint       The AbstractJoinPoint encapulates the method around which this aspect advice runs.</TD></TR><TR><TD CLASS="l">196</TD><TD>     * @param returnValue     The value returned from the execution of the profiled method, or null if the method</TD></TR><TR><TD CLASS="l">197</TD><TD>     *                        returned void or an exception was thrown.</TD></TR><TR><TD CLASS="l">198</TD><TD>     * @param exceptionThrown The exception thrown, if any, by the profiled method. Will be null if the method</TD></TR><TR><TD CLASS="l">199</TD><TD>     *                        completed normally.</TD></TR><TR><TD CLASS="l">200</TD><TD>     * @return The value to use as the StopWatch message.</TD></TR><TR><TD CLASS="l">201</TD><TD>     */</TD></TR><TR><TD CLASS="l">202</TD><TD>    protected String getStopWatchMessage(Profiled profiled,</TD></TR><TR><TD CLASS="l"><A NAME="4">203</A></TD><TD>                                         AbstractJoinPoint joinPoint,</TD></TR><TR><TD CLASS="l">204</TD><TD>                                         Object returnValue,</TD></TR><TR><TD CLASS="l">205</TD><TD>                                         Throwable exceptionThrown) {</TD></TR><TR><TD CLASS="l">206</TD><TD>        String message;</TD></TR><TR CLASS="c"><TD CLASS="l">207</TD><TD>        if (profiled.message().length() == 0) {</TD></TR><TR><TD CLASS="l">208</TD><TD>            // look for properties-based default</TD></TR><TR><TD CLASS="l">209</TD><TD>            // if the message name is not explicitly set on the Profiled annotation,</TD></TR><TR CLASS="c"><TD CLASS="l">210</TD><TD>            String property = String.format(&#34;message.%s.%s&#34;, joinPoint.getDeclaringClass().getName(), joinPoint.getMethodName());</TD></TR><TR CLASS="c"><TD CLASS="l">211</TD><TD>            message = JperfProperties.INSTANCE.getProperty(property);</TD></TR><TR><TD CLASS="l">212</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">213</TD><TD>            if (message == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">215</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">216</TD><TD>            if (message.contains(&#34;{&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">217</TD><TD>                message = evaluateJexl(message, joinPoint, returnValue, exceptionThrown);</TD></TR><TR><TD CLASS="l">218</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">219</TD><TD>        } else if (profiled.el() &amp;&amp; profiled.message().contains(&#34;{&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">220</TD><TD>            message = evaluateJexl(profiled.message(), joinPoint, returnValue, exceptionThrown);</TD></TR><TR CLASS="c"><TD CLASS="l">221</TD><TD>            if (&#34;&#34;.equals(message)) {</TD></TR><TR CLASS="z"><TD CLASS="l">222</TD><TD>                message = null;</TD></TR><TR><TD CLASS="l">223</TD><TD>            }</TD></TR><TR><TD CLASS="l">224</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">225</TD><TD>            message = profiled.message();</TD></TR><TR><TD CLASS="l">226</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">227</TD><TD>        return message;</TD></TR><TR><TD CLASS="l">228</TD><TD>    }</TD></TR><TR><TD CLASS="l">229</TD><TD> </TD></TR><TR><TD CLASS="l">230</TD><TD>    /**</TD></TR><TR><TD CLASS="l">231</TD><TD>     * Helper method is used to parse out {expressionLanguage} elements from the text and evaluate the strings using</TD></TR><TR><TD CLASS="l">232</TD><TD>     * JEXL.</TD></TR><TR><TD CLASS="l">233</TD><TD>     *</TD></TR><TR><TD CLASS="l">234</TD><TD>     * @param text            The text to be parsed.</TD></TR><TR><TD CLASS="l">235</TD><TD>     * @param joinPoint       The AbstractJoinPoint encapulates the method around which this aspect advice runs.</TD></TR><TR><TD CLASS="l">236</TD><TD>     * @param returnValue     The value returned from the execution of the profiled method, or null if the method</TD></TR><TR><TD CLASS="l">237</TD><TD>     *                        returned void or an exception was thrown.</TD></TR><TR><TD CLASS="l">238</TD><TD>     * @param exceptionThrown The exception thrown, if any, by the profiled method. Will be null if the method</TD></TR><TR><TD CLASS="l">239</TD><TD>     *                        completed normally.</TD></TR><TR><TD CLASS="l"><A NAME="a">240</A></TD><TD>     * @return The evaluated string.</TD></TR><TR><TD CLASS="l">241</TD><TD>     * @see Profiled#el()</TD></TR><TR><TD CLASS="l">242</TD><TD>     */</TD></TR><TR><TD CLASS="l">243</TD><TD>        protected String evaluateJexl(String text, AbstractJoinPoint joinPoint, Object returnValue, Throwable exceptionThrown) {</TD></TR><TR CLASS="c"><TD CLASS="l">244</TD><TD>        StringBuilder retVal = new StringBuilder(text.length());</TD></TR><TR CLASS="c"><TD CLASS="l">245</TD><TD>        JexlContext jexlContext = populateJexlContext(joinPoint, returnValue, exceptionThrown);</TD></TR><TR><TD CLASS="l">246</TD><TD> </TD></TR><TR><TD CLASS="l">247</TD><TD>        // look for {expression} in the passed in text</TD></TR><TR><TD CLASS="l">248</TD><TD>        int bracketIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">249</TD><TD>        int lastCloseBracketIndex = -1;</TD></TR><TR><TD CLASS="l">250</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">251</TD><TD>        while ((bracketIndex = text.indexOf('{', lastCloseBracketIndex + 1)) &gt;= 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">252</TD><TD>            appendNonJexlText(retVal, text, bracketIndex, lastCloseBracketIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">253</TD><TD>            lastCloseBracketIndex = lastCloseBracketIndex(text, bracketIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">254</TD><TD>            String expressionText = textBetweenBrackets(text, bracketIndex, lastCloseBracketIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">255</TD><TD>            evaluateJexlAndSetOnResult(retVal, expressionText, jexlContext);</TD></TR><TR CLASS="c"><TD CLASS="l">256</TD><TD>        }</TD></TR><TR><TD CLASS="l">257</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">258</TD><TD>        appendFinalPart(retVal, text, lastCloseBracketIndex);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="7">259</A></TD><TD>        return retVal.toString();</TD></TR><TR><TD CLASS="l">260</TD><TD>    }</TD></TR><TR><TD CLASS="l">261</TD><TD> </TD></TR><TR><TD CLASS="l">262</TD><TD>    private void appendFinalPart(StringBuilder retVal, String text, int lastCloseBracketIndex) {</TD></TR><TR CLASS="c"><TD CLASS="l">263</TD><TD>        if (lastCloseBracketIndex &lt; text.length()) {</TD></TR><TR CLASS="c"><TD CLASS="l">264</TD><TD>            retVal.append(text.substring(lastCloseBracketIndex + 1, text.length()));</TD></TR><TR><TD CLASS="l"><A NAME="5">265</A></TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">266</TD><TD>    }</TD></TR><TR><TD CLASS="l">267</TD><TD> </TD></TR><TR><TD CLASS="l">268</TD><TD>    private void evaluateJexlAndSetOnResult(StringBuilder retVal, String expressionText, JexlContext jexlContext) {</TD></TR><TR CLASS="c"><TD CLASS="l">269</TD><TD>        if (expressionText.length() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">270</TD><TD>            return;</TD></TR><TR><TD CLASS="l">271</TD><TD>        }</TD></TR><TR><TD CLASS="l">272</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">273</TD><TD>            Object result = getJexlExpression(expressionText).evaluate(jexlContext);</TD></TR><TR CLASS="c"><TD CLASS="l">274</TD><TD>            retVal.append(result);</TD></TR><TR CLASS="c"><TD CLASS="l">275</TD><TD>        } catch (Exception e) {</TD></TR><TR><TD CLASS="l">276</TD><TD>            //we don't want to propagate exceptions up</TD></TR><TR CLASS="c"><TD CLASS="l">277</TD><TD>            retVal.append(&#34;_EL_ERROR_&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="f">278</A></TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">279</TD><TD>    }</TD></TR><TR><TD CLASS="l">280</TD><TD> </TD></TR><TR><TD CLASS="l">281</TD><TD>    private String textBetweenBrackets(String text, int bracketIndex, int lastCloseBracketIndex) {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="8">282</A></TD><TD>        return text.substring(bracketIndex + 1, lastCloseBracketIndex);</TD></TR><TR><TD CLASS="l">283</TD><TD>    }</TD></TR><TR><TD CLASS="l">284</TD><TD> </TD></TR><TR><TD CLASS="l">285</TD><TD>    private void appendNonJexlText(StringBuilder retVal, String text, int bracketIndex, int lastCloseBracketIndex) {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="d">286</A></TD><TD>        retVal.append(text.substring(lastCloseBracketIndex + 1, bracketIndex));</TD></TR><TR CLASS="c"><TD CLASS="l">287</TD><TD>    }</TD></TR><TR><TD CLASS="l">288</TD><TD> </TD></TR><TR><TD CLASS="l">289</TD><TD>    private int lastCloseBracketIndex(String text, int bracketIndex) {</TD></TR><TR CLASS="c"><TD CLASS="l">290</TD><TD>        int index = text.indexOf('}', bracketIndex + 1);</TD></TR><TR CLASS="c"><TD CLASS="l">291</TD><TD>        if (index == -1) {</TD></TR><TR><TD CLASS="l">292</TD><TD>            //if there wasn't a closing bracket index just go to the end of the string</TD></TR><TR CLASS="c"><TD CLASS="l">293</TD><TD>            index = text.length();</TD></TR><TR><TD CLASS="l">294</TD><TD>        }</TD></TR><TR><TD CLASS="l">295</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">296</TD><TD>        return index;</TD></TR><TR><TD CLASS="l"><A NAME="e">297</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">298</TD><TD> </TD></TR><TR><TD CLASS="l">299</TD><TD>    @SuppressWarnings(&#34;unchecked&#34;)</TD></TR><TR><TD CLASS="l">300</TD><TD>    private JexlContext populateJexlContext(AbstractJoinPoint joinPoint, Object returnValue, Throwable exceptionThrown) {</TD></TR><TR CLASS="c"><TD CLASS="l">301</TD><TD>        Object[] args = joinPoint.getParameters();</TD></TR><TR><TD CLASS="l">302</TD><TD> </TD></TR><TR><TD CLASS="l">303</TD><TD>        //create a JexlContext to be used in all evaluations</TD></TR><TR CLASS="c"><TD CLASS="l">304</TD><TD>        JexlContext jexlContext = new HashMapContext();</TD></TR><TR CLASS="c"><TD CLASS="l">305</TD><TD>        for (int i = 0; i &lt; args.length; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">306</TD><TD>            jexlContext.getVars().put(&#34;$&#34; + i, args[i]);</TD></TR><TR><TD CLASS="l">307</TD><TD>        }</TD></TR><TR><TD CLASS="l">308</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">309</TD><TD>        Class&lt;?&gt; declaringClass = joinPoint.getDeclaringClass();</TD></TR><TR CLASS="c"><TD CLASS="l">310</TD><TD>        jexlContext.getVars().put(&#34;$methodName&#34;, joinPoint.getMethodName());</TD></TR><TR CLASS="c"><TD CLASS="l">311</TD><TD>        jexlContext.getVars().put(&#34;$this&#34;, joinPoint.getExecutingObject());</TD></TR><TR CLASS="c"><TD CLASS="l">312</TD><TD>        jexlContext.getVars().put(&#34;$class&#34;, declaringClass);</TD></TR><TR CLASS="c"><TD CLASS="l">313</TD><TD>        jexlContext.getVars().put(&#34;$className&#34;, declaringClass.getName());</TD></TR><TR CLASS="c"><TD CLASS="l">314</TD><TD>        jexlContext.getVars().put(&#34;$classSimpleName&#34;, declaringClass.getSimpleName());</TD></TR><TR CLASS="c"><TD CLASS="l">315</TD><TD>        jexlContext.getVars().put(&#34;$return&#34;, returnValue);</TD></TR><TR CLASS="c"><TD CLASS="l">316</TD><TD>        jexlContext.getVars().put(&#34;$exception&#34;, exceptionThrown);</TD></TR><TR><TD CLASS="l">317</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">318</TD><TD>        return jexlContext;</TD></TR><TR><TD CLASS="l">319</TD><TD>    }</TD></TR><TR><TD CLASS="l">320</TD><TD> </TD></TR><TR><TD CLASS="l">321</TD><TD>    /**</TD></TR><TR><TD CLASS="l">322</TD><TD>     * Helper method gets a compiled JEXL expression for the specified expression text, either from the cache or by</TD></TR><TR><TD CLASS="l">323</TD><TD>     * creating a new compiled expression.</TD></TR><TR><TD CLASS="l">324</TD><TD>     *</TD></TR><TR><TD CLASS="l">325</TD><TD>     * @param expressionText The JEXL expression text</TD></TR><TR><TD CLASS="l"><A NAME="b">326</A></TD><TD>     * @return A compiled JEXL expression representing the expression text</TD></TR><TR><TD CLASS="l">327</TD><TD>     * @throws Exception Thrown if there was an error compiling the expression text</TD></TR><TR><TD CLASS="l">328</TD><TD>     */</TD></TR><TR><TD CLASS="l">329</TD><TD>    protected Expression getJexlExpression(String expressionText) throws Exception {</TD></TR><TR CLASS="c"><TD CLASS="l">330</TD><TD>        Expression retVal = jexlExpressionCache.get(expressionText);</TD></TR><TR CLASS="c"><TD CLASS="l">331</TD><TD>        if (retVal == null) {</TD></TR><TR><TD CLASS="l">332</TD><TD>            //Don't need synchronization here - if we end up calling createExpression in 2 separate threads, that's fine</TD></TR><TR CLASS="c"><TD CLASS="l">333</TD><TD>            jexlExpressionCache.put(expressionText, retVal = ExpressionFactory.createExpression(expressionText));</TD></TR><TR><TD CLASS="l">334</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">335</TD><TD>        return retVal;</TD></TR><TR><TD CLASS="l">336</TD><TD>    }</TD></TR><TR><TD CLASS="l">337</TD><TD>}</TD></TR></TABLE><P></P><TABLE WIDTH="100%" CLASS="hdft" CELLSPACING="0"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="e.html">net.jperf.aop</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>